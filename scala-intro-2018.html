<!doctype html>
<html lang="en">

<!-- print with:
phantomjs plugin/print-pdf/print-pdf.js "file:///Users/adriaan/git/reveal.js/scala-intro-2018.html?print-pdf" scala-intro.pdf 1200x800
-->

<head>
  <meta charset="utf-8">

  <title>Scala</title>

  <meta name="description" content="Introduction to Scala, 2018">
  <meta name="author" content="Adriaan Moors">

  <meta name="apple-mobile-web-app-capable" content="yes" />
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, minimal-ui">

  <link rel="stylesheet" href="css/reveal.css">
  <link rel="stylesheet" href="css/theme/typesafe.css" id="theme">

  <!-- Code syntax highlighting -->
  <link rel="stylesheet" href="lib/css/zenburn.css">

  <!-- Printing and PDF exports -->
  <script>
    var link = document.createElement( 'link' );
    link.rel = 'stylesheet';
    link.type = 'text/css';
    link.href = window.location.search.match( /print-pdf/gi ) ? 'css/print/pdf.css' : 'css/print/paper.css';
    document.getElementsByTagName( 'head' )[0].appendChild( link );
  </script>


  <!--[if lt IE 9]>
  <script src="lib/js/html5shiv.js"></script>
  <![endif]-->
</head>

<body>

<div class="reveal">

<div class='footer'><img style="height:1.5em; opacity: 0.66" src="images/lightbend-color-reverse.svg" title="Lightbend" alt="Lightbend"/></div>

<div class="slides">

<section><img src="images/lightbend-color-reverse.svg" title="Lightbend" style="width: 66%;" alt="Lightbend"/></section>

<section>
<h2>Scala</h2>
<!-- <h3 class="orange"></h3> -->
<h4 style="margin-top:75px">Adriaan <a style="opacity:0.75" href="http://twitter.com/adriaanm">@adriaanm</a> Moors</h4>
<h5 class="orange">Scala Team Lead</h5>
<h5 style="opacity: 0.75">https://github.com/adriaanm/talks/</h5>
</section>


<section> <!-- INTRO: WHY -->

<section data-markdown><script type="text/template">
# Scala
</script></section>

<section data-markdown><script type="text/template">
## Who?
 - Martin Odersky & team at EPFL, 
 - many OSS contributors! github.com/scala/scala
</script></section>

<section data-markdown><script type="text/template">
## Why?
### Java was stagnating
<small>(Martin wrote generic javac, but generics got commented out for 1.4â€¦)</small>
### Bring FP from academia to mainstream
First big commercial adopter: Twitter in 2007
<small>(Now many millions of LoC.)</small>
### Less typing, more fun!
</script></section>

<section data-markdown><script type="text/template">
# Scala
## Unifies OO & FP
## Regular
## Pragmatic
</script></section>

<section data-markdown><script type="text/template">
# Unifier
## "Scala-ble"
  - FP & OOP
  - Safety in types & Convenience of inference
  - Oneliner â†’ N MLoC
</script></section>

<section data-markdown><script type="text/template">
# Regular
</script></section>

<section data-markdown><script type="text/template">
## Syntactically

```scala
val    x              : T      = ???
def    m [Ti] (ai: Ui): U      = ???
class  C [Ti] (ai: Ui) extends P(aj) { â€¦ }
object o               extends C(ai) { â€¦ }
type   T                       = â€¦
type   T   >: L <: U
```
</script></section>

<section data-markdown><script type="text/template">
## Types come second
### because optional
  - public types are documentation
  - (â†” codegen: maintenance liability)
  - best types are unseen
    - e.g., definition-site variance
</script></section>

<section data-markdown><script type="text/template">
## Conceptually
### Pure OO
###  value = object
###  operation = method call
</script></section>

<section data-markdown><script type="text/template">
## No limits / exceptions
  - Arbitrary nesting
  - Higher-order (Methods and Types)
  - Operator names (Primitive types are types too)
</script></section>


<section data-markdown><script type="text/template">
### Everything is an expression
  - think in values, not side-effects
  - statement is expression `: Unit`
  - all types subject to polymorphism
  - âŸ¹ function types uniform
</script></section>

<section data-markdown><script type="text/template">
### Small core reaches far
#### Start small, grow methodically.
</script></section>

<section data-markdown><script type="text/template">
### Growing
  - `f(x)` = `f.apply(x)`
  - `for` comprehension
  - string interpolation
  - pattern matching / extractors
</script></section>

<section data-markdown><script type="text/template">
### Flexibility requires discipline

#### The language is not opinionated;
#### programmer needs to be!
</script></section>

<section data-markdown><script type="text/template">
# Practical

#### simplest solution
#### solves the problem today
#### can understand tomorrow
#### evolve later
</script></section>

<section data-markdown><script type="text/template">
# Pragmatic
  - similar to Java (syntax, in details)
  - target the JVM because of rich eco-system
  - used a lot for scalable back-ends (akka/play) and data science (spark, flink, kafka,â€¦)
  - also compiles to JavaScript and native
</script></section>

<section data-markdown><script type="text/template">
### Language is a tool

#### improve our understanding
#### through abstraction, static typing, purity
</script></section>

<section data-markdown><script type="text/template">
## Aid
### static types: refactor with confidence
type inference to refactor with ease

</script></section><section data-markdown><script type="text/template">

### FP: small abstractions in isolation
composed into different solutions

</script></section><section data-markdown><script type="text/template">
### abstraction: capture essence
not obscure it
<!-- balance abstraction cost versus cost of repeating yourself -->
</script></section>

<section data-markdown><script type="text/template">
## Shield fromâ€¦
### â€¦ implementation details: encapsulate!
OO's forte

</script></section><section data-markdown><script type="text/template">

### â€¦ time: immutable
mutability exposes order of execution

</script></section><section data-markdown><script type="text/template">
  
<!-- (side effects ephemeral, values are real) -->
### â€¦ space: asynchrony
synchrony exposes distance/failure
</script></section>

</section> <!-- /INTRO -->


<section> <!-- OO -->

<section data-markdown><script type="text/template">
# OO
## Programming with objects and methods
</script></section>

<section data-markdown><script type="text/template">
### Modularity
Interfaces and loose coupling

### Extensibility
Easily add new types
</script></section>

<section data-markdown><script type="text/template">
# Classes and objects

```scala
class Person(val name: String) {
  def `ðŸ‘‹` = println(s"Hi, $name!")

  override def toString = s"Person($name)"
}

object a extends Person("Adriaan")
```
</script></section>

<section data-markdown><script type="text/template">
# Class
  - (primary) constructor (args to init members)
  - `extends` one other class, multiple traits
  - may be `abstract` / `final` / `sealed`
  - declares members
  - contains expressions (often ðŸ¤”)
</script></section>

<section data-markdown><script type="text/template">
# Members
  - type: `class` / `trait` / `type`
  - value: `def` / `val` / `var` / `object`
  - syntax: `*keyword* *signature* [= *rhs*]`
  - public by default
  - abstract if there's no right hand side
</script></section>

<section data-markdown><script type="text/template">
## `def`
  - omitted return type is inferred
  - `override` must be specified
  - abstract: 
    - `def foo: Any`
  - may be polymorphic
    - `def id[T](x: T): T = x`
</script></section>

<section data-markdown><script type="text/template">
### Ã  propos: dependent types
  - types can depend on argument *values*
    - `def idReally(x: AnyRef): x.type = x`
  - `p.type` qualifies terms statically known to be `eq p`
  - also supports literals ðŸ˜Ž 
    - `1: 1` and `"a" : "a"` ðŸ¤¯
</script></section>

<section data-markdown><script type="text/template">
## Access
  - Over-designed feature of Scalaâ€¦ <small>(+ hard to compile to JVM)</small>
  - Probably best to stick to `private`,
    - possibly qualified: `private[this]`, `private[somePkg]`
  - also have `protected`, but should we really privilege subclasses?
</script></section>

<section data-markdown><script type="text/template">
## `def`
  - multiple argument lists: 

```scala
// repl time!
def repeat(n: Int)(s: String): String = s * n
val thrice = repeat(3) // ðŸ‘€
```
  
</script></section>

<section data-markdown><script type="text/template">
# Member
## `val` / `var` / `lazy val`
  - prefer `val`, but `var` is there if you need it
  - `lazy val` cannot be abstract (just write a `val`)
</script></section>

<section data-markdown><script type="text/template">
### Uniform Access Principle
&nbsp;

```scala
trait HasX {
  def x: Int
  def x_= (v: Int): Unit
}

class C extends HasX { var x: Int = 1 }

val hasX: HasX = new C

hasX.x = 2

println(hasX.x)
```
</script></section>

<section data-markdown><script type="text/template">
### Uniform Access Principle
&nbsp;

```scala
trait HasX {  def x: Int }

// subclass implements abstract getter using `val`
// (but not vice versa! why?)
class C extends HasX { val x: Int = 1 }
```
</script></section>

<section data-markdown><script type="text/template">
# Object
  - single instance, lazily initialized
  - usually defined together with class ("companion")
  - `object` member replaces `static` class member
</script></section>



<section data-markdown><script type="text/template">
# Case Class

## reduce boilerplate
  - structuring & destructuring blobs of data
  - compiler synthesizes methods: *implementation follows structure*

</script></section>


<section data-markdown><script type="text/template">
## Case Class Syntactic sugar

```scala
case class Person(name: String)
```

Expands to: <small>(will explain why soon)</small>
  
```scala
class Person(val name: String) {
  override def equals(x: Any): Boolean = (this eq x) || (
    x match {
      case x: Person => name == x.name
      case _ => false
    }
}

// companion object
object Person {
  def apply(name: String): Person = new Person(name)
  def unapply(x: Person): Option[String] = 
    if (x == null) None else Some(x.name)
}
```
</script></section>


<section data-markdown><script type="text/template">
### Constructing a `Person`
```
val p1 = Person("p1") // desugars to:
val p1 = Person.apply("p1") // could have smarter `apply` method
val p1 = new Person("p1") // allowed too, but `new` is fixed
```

Putting this in reverse:
```
val Person(name) = p1 // desugars to:
val name = Person.unapply(p1).get
```
</script></section>

<section data-markdown><script type="text/template">
# Traits

```scala
trait Waveable { 
  def name: String
  def `ðŸ‘‹` = println(s"Hi, $name!")
}

case class Person(name: String) extends Waveable

Person("everyone").`ðŸ‘‹`
```
</script></section>

<section data-markdown><script type="text/template">
# Traits
 - Much like Java 8 interfaces, but with fewer restrictions. 
 - May declare same members as a class.

## Linearisation
Difference with class: don't statically know `super`
</script></section>


<section data-markdown><script type="text/template">
# Trait Linearisation
## Disclaimer: don't do this

```scala
trait Property[T] { 
  def set(x: T): Unit = _x = x; def get: T = _x
  private var _x: T = _ 
}
trait Logged[T] extends Property[T] { 
  override def set(x: T) = { println(s"Setting to $x")
    super.set(x)
  } 
}
trait Encrypted[T] extends Property[T] { 
  override def set(x: T) = super.set(encrypted(x))
  def encrypted(x: T) = null.asInstanceOf[T] 
}
// the order of traits determines where `super` calls above g
class Pass extends Logged[String] with Encrypted[String]
class OOps extends Encrypted[String] with Logged[String]
```

</script></section>

<section data-markdown><script type="text/template">
# String Interpolation

`s"Hello $name"` desugars to method calls:

```scala
scala> val name = "a"
name: String = a

scala> s"Hello $name" // print
scala.StringContext.apply("Hello ", "").s(name) // : String
```
&nbsp;

#### can provide your own `StringContext`, interpolators
</script></section>


</section> <!-- /OO -->



<section> <!-- FP -->

<section data-markdown><script type="text/template">
# FP
## Programming with functions
</script></section>

<section data-markdown><script type="text/template">
### Modularity
Often outside language, more restrained

### Extensibility
Easily add new operations
</script></section>


<section data-markdown><script type="text/template">
# Simplicity
  - expressions (de)construct values (~~mutate data~~)
  - understand function purely in terms of input
  - compose functions safely into program 
    - (higher-order functions / combinators)
    - type system tracks "flow of data"
</script></section>

<section data-markdown><script type="text/template">
## Expression-based
### Cohesion
```scala
process(if (c) fooBar else woeleWoele)
```

more direct than

```scala
if (c) process(fooBar) else process(woeleWoele)
```
</script></section>

<section data-markdown><script type="text/template">
## Expression-based
### Cohesion?

```scala
var arg: Int = _

if (c) arg = woeleWoele 
else arg = fooBar

/* what was I doing again? */

process(arg) // oh yeah
```
</script></section>

<section data-markdown><script type="text/template">
# So, functions
  - type: `(A1, â€¦, An) => Result`
  - expression: `(x1, â€¦, xn) => y`
  - shorthand / syntactic sugar: 
    - `(A1, â€¦, An) => Result` = `FunctionN[A1,â€¦, An, Result]`
    - `f(x)` = `f.apply(x)`
    - `x => x.+(1)` â˜ž `x => x + 1` â˜ž `_ + 1` 
</script></section>

<section data-markdown><script type="text/template">
# Function = object
  - predefined `FunctionN` classes (`N=1..22`)
  - or your own: 
    - `trait F { def apply(x: Int): Int }`
  - or: Java 8's Single Abstract Method representation
</script></section>

<section data-markdown><script type="text/template">
# Philosophical interlude
  - FP
    - abstract using parameter: `x => â€¦
    - concretise with function application: `f(a)`
  - OO
    - abstract member**s**: 
      - `trait T { def a ; def b }`
    - concretise by implementing members:
      - `new T { def a = ??? ; def b = ??? }`
</script></section>

<section data-markdown><script type="text/template">
# Tuples
Predefined case classes with numbered fields instead of named ones.

```scala
val pair = (1, 2) // short for Tuple2(1, 2)
pair._1

case class Pair[A, B](_1: A, _2: B)
val myPair = Pair(1, 2)

val Pair(x, y) = myPair
```
</script></section>

<section data-markdown><script type="text/template">
# Tuple0?
```scala
val tuple0 = () // ðŸ¤”
```

</script></section>

<section data-markdown><script type="text/template">
# Pattern matching
  - Patterns: values with holes, `match` recovers holes' values
  - Compiler warns if a match is incomplete (not exhaustive)
  - Unhandled cases throw `MatchError` exception
  - Respects OO encapsulation (abstractions are in control of how they are destructured: `unapply`)
</script></section>

<section data-markdown><script type="text/template">
# Example: pattern matching & recursion
```scala
// What does signature promise?
def reverse[T](xs: List[T]): List[T] = {
  def loop(xs: List[T], acc: List[T]): List[T] = xs match {
    case Nil => acc // what if we forgot about this one?
    case x :: xs => loop(xs, x :: acc)
  }
  loop(xs, Nil)
}
```
</script></section>


<section data-markdown><script type="text/template">
# `for` comprehension
Another example of syntactic sugar. Expands into method calls (map/flatMap/withFilter/â€¦).

```scala
for (x <- List(1,2,3,4) ; if x % 2 == 0) yield x // print
```

Using `filter` (higher-order method)

```
List(1,2,3,4).filter(_ % 2 == 0)
```

</script></section>



<section data-markdown><script type="text/template">
# Implicits
  - Type checker supplies implicit argument if known precisely from type.
  - cf. Haskell type classes

&nbsp;

```scala
def foo(â€¦)(implicit logger: Logger) = ???

implicit val myLogger: Logger = new MyLogger
foo(â€¦) // no need to specify logger arg
```

</script></section>


<!-- 
<section data-markdown><script type="text/template">
  type constructor polymorphism
</script></section>
 -->


<section data-markdown><script type="text/template">
## We got y'all
### The type checker has your back.
</script></section>


<section data-markdown><script type="text/template">
##  How I stopped worrying about variance
### "Just add +/- until it compiles."
### <div style="text-align: right; padding-right: 1em">-- me</div>
</script></section>

<section data-markdown><script type="text/template">
## Type system working for you
### Definition specifies variance
```scala
trait Function1[-A, +R] { def apply(x: A): R }
```
&nbsp;

### Subtyping intuition:
You may supply a "better" function that:
  - imposes fewer restrictions on its arguments and 
  - makes more promises about its result.
</script></section>

<section data-markdown><script type="text/template">
## Function subtyping

### Scala: no fuss

```scala
def map[R](mapper: T => R): Stream[R]
```
&nbsp;

### Java: wildcards for use-site variance

```java
<R> Stream<R> map(Function<? super T, ? extends R> mapper)
```

So that callers of `map` may supply a "better" function:

</script></section>






</section> <!-- /FP -->



<section>
<section data-markdown><script type="text/template">  
## Thank you
### More Questions!
</script></section>
</section>


<script src="lib/js/head.min.js"></script>
<script src="js/reveal.js"></script>

<script>
  // Full list of configuration options available at:
  // https://github.com/hakimel/reveal.js#configuration
  Reveal.initialize({
    controls: true,
    progress: true,
    slideNumber: true,
    history: true,
    center: true,
    help: true,
    transition: 'fade', // none/fade/slide/convex/concave/zoom

    // Optional reveal.js plugins
    dependencies: [
      { src: 'lib/js/classList.js', condition: function() { return !document.body.classList; } },
      { src: 'plugin/markdown/marked.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
      { src: 'plugin/markdown/markdown.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
      { src: 'plugin/highlight/highlight.js', async: true, condition: function() { return true; }, callback: function() { hljs.initHighlightingOnLoad(); } },
      { src: 'plugin/zoom-js/zoom.js', async: true },
      { src: 'plugin/notes/notes.js', async: true }
    ]
  });

</script>
</body>
</html>
